{"version":3,"sources":["../src/ProcessPool.js"],"names":[],"mappings":"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","file":"src/ProcessPool.js","sourcesContent":["import Promise from 'bluebird'\nimport child_process from 'child_process'\nimport path from 'path'\nimport _ from 'lodash'\n\nimport functionPool from './functionPool'\nimport functionLimit from './functionLimit'\n\n/**\n * Take sub-process and wrap the messaging to/back into a function that accepts\n * arguments to send over IPC and returns a promise that will resolve to the\n * return value, received via IPC.\n */\nfunction wrapSubprocess(subProcessPromise) {\n  // TODO: use utility to bind promise from event instead of creating the promise manually\n  return (...args) => subProcessPromise.then(subProcess => {\n    subProcess.send(args)\n\n    return new Promise((resolve, reject) => {\n      var onExit = () => reject(Error('killed'))\n      var onMessage = res => {\n        if (typeof res === 'object' && null !== res) {\n          if ('$$return$$' in res || '$$error$$' in res) {\n            subProcess.removeListener('exit', onExit)\n            subProcess.removeListener('message', onMessage)\n            if ('$$return$$' in res) {\n              resolve(res.$$return$$)\n            } else {\n              var err = Error(res.$$error$$)\n              err.stack = res.stack\n              reject(err)\n            }\n          }\n        }\n      }\n      subProcess.once('exit', onExit)\n      subProcess.on('message', onMessage)\n    })\n  })\n}\n\n/**\n * Pool class with fields:\n *  * length: Number of processes to run at any one time\n */\nexport default class {\n  // TODO: default to number of CPU cores\n  constructor({ processLimit = 4 } = {}) {\n    this.processLimit = processLimit\n    this._reset()\n  }\n\n  _reset() {\n    this.limiter = functionLimit(func => func(), this.processLimit)\n    this.preparedFuncs = []\n    this.nStarting = 0 // number of processes starting up\n  }\n\n  /**\n   * Prepare a function to be run within a process\n   * @param {Function} func This function is immediately executed when the\n   * subprocess starts and should return another function that will handle\n   * each call.\n   * @param {Any} context Optional value to pass to the outter function within\n   * the subprocess, it must be convertable to JSON.\n   * @param {Object|undefined} options processLimit and replace options, usually\n   * this.processLimit functions are spawned for each pooled function, this can be\n   * used to set the limit lower or higher for a given function. Setting it higher\n   * will not allow greater concurrency for this function but will allow the function\n   * to deal with processes being killed more quickly.\n   */\n  prepare(\n    func,\n    context = undefined,\n    { processLimit = this.processLimit, module: _module, onChildProcessSpawned = _.noop } = {}\n  )\n  {\n    var funcData = {\n      context,\n      module: _module || module.parent,\n      subProcesses: [],\n      func\n    }\n    this.preparedFuncs.push(funcData)\n\n    var ret = funcData.pool = functionPool(this._spawnSubprocesses(processLimit, funcData, onChildProcessSpawned))\n    ret.kill = this._kill.bind(this, funcData)\n    return ret\n  }\n\n  _spawnSubprocesses(count, funcData, onChildProcessSpawned = _.noop) {\n    var { module, context } = funcData\n\n    var spArgs = {\n      $$prepare$$: funcData.func.toString(),\n      modulePaths: module.paths,\n      moduleFilename: module.filename\n    }\n    if (context)\n      spArgs.context = context\n\n    // TODO: add hooks to detect subprocess exit failure\n    var subProcesses = _.range(0, count).map(() => child_process.fork(\n      path.join(__dirname, 'childProcess')\n    ))\n\n    funcData.subProcesses.push(...subProcesses)\n\n    this.nStarting += subProcesses.length\n\n    return subProcesses.map((subProc, idx) => {\n      var spPromise = new Promise(resolve => {\n        subProc.send(spArgs)\n        subProc.once('message', () => {\n          onChildProcessSpawned(subProc)\n          this._subProcessReady()\n          resolve(subProc)\n        })\n      })\n\n      var wrapped = wrapSubprocess(spPromise)\n      var ret = (...args) => this.limiter(wrapped.bind(this, ...args))\n      ret.subProcess = subProcesses[idx]\n      return ret\n    })\n  }\n\n  _kill(funcData) {\n    var { pool, subProcesses } = funcData\n    var killed = []\n    pool.running.forEach(runningFunc => {\n      killed.push(runningFunc)\n      var { subProcess } = runningFunc\n      subProcess.kill()\n      subProcesses.splice(subProcesses.indexOf(subProcess), 1)\n    })\n\n    if (killed.length > 0) {\n      var newFuncs = this._spawnSubprocesses(killed.length, funcData)\n      killed.forEach((func, idx) => {\n        pool.replace(func, newFuncs[idx])\n      })\n    }\n\n    return killed.map(funcData => funcData.subProcess.pid)\n  }\n\n  _subProcessReady() {\n    --this.nStarting\n    if (this._onStart && this.nStarting === 0) {\n      this._onStart.fulfill()\n      delete this._onStart\n    }\n  }\n\n  /**\n   * Return a promise that resolves when all of the subprocesses have started up.\n   */\n  ready() {\n    if (this.nStarting === 0)\n      return Promise.resolve()\n\n    if (! this._onStart)\n      this._onStart = Promise.pending()\n    return this._onStart.promise\n  }\n\n  /**\n   * Destroy all pooled subprocesses, do not use them after this.\n   */\n  destroy() {\n    this.preparedFuncs.forEach(funcData => {\n      funcData.subProcesses.forEach(proc => proc.kill())\n    })\n    this._reset()\n  }\n}\n"]}